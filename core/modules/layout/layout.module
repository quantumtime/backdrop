<?php

/**
 * @file
 * The page manager module provides a UI and API to manage pages.
 *
 * It defines pages, both for system pages, overrides of system pages, and
 * custom pages using Drupal's normal menu system. It allows complex
 * manipulations of these pages, their content, and their hierarchy within
 * the site. These pages can be exported to code for superior revision
 * control.
 */

/**
 * Layouts constant for user-defined layouts.
 */
const LAYOUT_STORAGE_NORMAL = 1;

/**
 * Layout constant for layouts that override module-defined presets.
 */
const LAYOUT_STORAGE_OVERRIDE = 2;

/**
 * Layout constant for module-defined layouts.
 */
const LAYOUT_STORAGE_DEFAULT = 4;

/**
 * Implements hook_permission().
 */
function page_manager_permission() {
  return array(
    'administer layouts' => array(
      'title' => t('Administer Layouts'),
      'description' => t('Add and modify layouts on pages.'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_menu().
 */
function layout_menu() {
  $items = array();
  $base = array(
    'access arguments' => array('administer layouts'),
    'file' => 'includes/layout.admin.inc',
    'theme callback' => 'ajax_base_page_theme',
  );

  $items['admin/structure/layouts'] = array(
    'title' => 'Layouts',
    'description' => 'Create new landing pages or modify the layout of existing pages on your site.',
    'page callback' => 'layout_list_page',
  ) + $base;

  $items['admin/structure/layouts/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -10,
  );

  $items['admin/structure/layouts/edit/%layout_cache'] = array(
    'title' => 'Edit',
    'page callback' => 'layout_edit_layout',
    'page arguments' => array(4),
    'type' => MENU_NORMAL_ITEM,
  ) + $base;

  $items['admin/structure/layouts/%layout_js/operation/%layout_cache'] = array(
    'page callback' => 'layout_edit_layout_operation',
    'page arguments' => array(3, 5),
    'type' => MENU_NORMAL_ITEM,
  ) + $base;

  $items['admin/structure/layouts/%layout_js/enable/%layout_cache'] = array(
    'page callback' => 'layout_enable_layout',
    'page arguments' => array(FALSE, 3, 5),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/%layout_js/disable/%layout_cache'] = array(
    'page callback' => 'layout_enable_layout',
    'page arguments' => array(TRUE, 3, 5),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/add'] = array(
      'title' => 'Add new layout',
      'page callback' => 'layout_add_page',
      'page arguments' => array(),
      'type' => MENU_LOCAL_ACTION,
    ) + $base;

  // AJAX callbacks for argument modal.
  $items['admin/structure/pages/argument'] = array(
      'page callback' => 'page_manager_page_subtask_argument_ajax',
      'type' => MENU_CALLBACK,
    ) + $base;

  // Add menu entries for each custom layout path.
  foreach (layout_get_all_layouts() as $layout_name => $layout) {
    if (!empty($layout->disabled)) {
      continue;
    }

    if (!isset($layout->access['type'])) {
      $layout->access['type'] = 'none';
    }
    if (!isset($layout->access['settings'])) {
      $layout->access['settings'] = NULL;
    }

    $path             = array();
    $page_arguments   = array($layout_name);
    $access_arguments = array($layout->access);
    $load_arguments   = array($layout_name, '%index', '%map');

    // Replace named placeholders with our own placeholder to load contexts.
    $position = 0;

    foreach (explode('/', $layout->path) as $bit) {
      // Remove things like double slashes completely.
      if (!isset($bit) || $bit === '') {
        continue;
      }

      if ($bit[0] == '%' && $bit != '%') {
        $placeholder = '%layout_arg';

        // Chop off that %.
        $name = substr($bit, 1);

        // Check to see if the argument plugin wants to use a different
        // placeholder. This will allow to_args.
        if (!empty($layout->arguments[$name])) {
          if (!empty($layout->arguments[$name]['name'])) {
            // @port: previously ctools_get_argument.
            $plugin = layout_get_argument($layout->arguments[$name]['name']);
            if (isset($plugin['path placeholder'])) {
              if (function_exists($plugin['path placeholder'])) {
                $placeholder = $plugin['path placeholder']($layout->arguments[$name]);
              }
              else {
                $placeholder = $plugin['path placeholder'];
              }
            }
          }
        }
        // If an argument, swap it out with our argument loader and make sure
        // the argument gets passed through to the page callback.
        $path[]             = $placeholder;
        $page_arguments[]   = $position;
        $access_arguments[] = $position;
      }
      else if ($bit[0] != '!') {
        $path[] = $bit;
      }

      // Increment position. We do it like this to skip empty items that
      // could happen from erroneous paths like: this///that
      $position++;
    }

    $menu_path = implode('/', $path);

    $items[$menu_path] = layout_custom_page_menu_item($layout->menu, $access_arguments, $page_arguments, $load_arguments);

    // Add a parent menu item if one is configured.
    if (isset($layout->menu['type']) && $layout->menu['type'] == 'default tab') {
      array_pop($path);
      $parent_path = implode('/', $path);
      $items[$parent_path] = layout_custom_page_menu_item($layout->menu['parent'], $access_arguments, $page_arguments, $load_arguments);
    }
  }

  return $items;
}

/**
 * Check to see if the incoming menu item is js capable or not.
 *
 * This can be used as %layout_js as part of a path in hook menu. CTools
 * ajax functions will automatically change the phrase 'nojs' to 'ajax'
 * when it attaches ajax to a link. This can be used to autodetect if
 * that happened.
 */
function layout_js_load($js) {
  if ($js == 'ajax') {
    return TRUE;
  }
  return 0;
}

/*
 * Implements hook_theme()
 */
function layout_theme() {
  $base = array(
    'file' => 'includes/layout.theme.inc',
  );

  $items = array(
    'layout_path_rearrange_layouts' => array(
      'render element' => 'form',
    ) + $base,
    'layout_edit_form' => array(
      'template' => 'templates/layout-edit-page',
      'render element' => 'form',
    ) + $base,
    'layout_info' => array(
      'variables' => array('layout' => NULL),
    ) + $base,
    'layout_option' => array(
      'variables' => array('layout_info' => NULL),
    ) + $base,
  );

  return $items;
}

/**
 * Implements hook_layout_api().
 */
function layout_layout_api() {
  return array(
    'file' => 'includes/layout.layout.inc',
  );
}

/**
 * Return an array of all layouts as fully loaded $layout objects.
 */
function layout_get_all_layouts() {
  $layouts = &drupal_static(__FUNCTION__, array());
  $configs = config_get_names_with_prefix('layout.layout.');
  foreach ($configs as $config_file) {
    $config = config($config_file);
    $name = str_replace('layout.layout.', '', $config_file);
    $layouts[$name] = new Layout($config->get());
  }
  return $layouts;
}

/**
 * Load all include files for modules that implement hook_layout_api().
 */
function _layout_include_module_files() {
  $included = &drupal_static(__FUNCTION__, FALSE);
  if (!$included) {
    foreach (module_implements('layout_api') as $module) {
      $function = $module . '_layout_api';
      $api_info = $function();
      if (isset($api_info['file'])) {
        include_once(DRUPAL_ROOT . '/' . drupal_get_path('module', $module) . '/' . $api_info['file']);
      }
    }
    $included = TRUE;
  }
}

/**
 * Load a layout-related information from modules.
 */
function _layout_get_all_info($data_type) {
  $all_info = &drupal_static(__FUNCTION__);
  if (!isset($all_info)) {
    _layout_include_module_files();
    if ($cached_info = cache()->get($data_type . '_info')) {
      $all_info = $cached_info->data;
    }
    else {
      $all_info = array();
      foreach (module_implements($data_type . '_info') as $module) {
        $function = $module . '_' . $data_type . '_info';
        $data = $function();
        foreach ($data as $key => $info) {
          $info['module'] = $module;
          $all_info[$key] = $info;
        }
      }
      cache()->set($data_type . '_info', $all_info);
    }
  }
  return $all_info;
}

/**
 * Load all layout information from modules.
 */
function layout_get_layout_info() {
  return _layout_get_all_info('layout');
}

/**
 * Load all layout information from modules.
 */
function layout_get_context_info() {
  return _layout_get_all_info('context');
}

/**
 * Helper function to instantiate handlers when loading from config.
 *
 * @param string $handler
 *   The class name of the handler to instantiate.
 * @param array $config
 *   The configuration options for the handler being created.
 */
function layout_create_handler($handler, array $config = array()) {
  if (!class_exists($handler)) {
    $handler = 'LayoutBrokenHandler';
  }
  return new $handler($config);
}

/**
 * Get the cached changes to a given task handler.
 *
 * The page cache is used to store a page temporarily, using the ctools object
 * cache. When loading from the page cache, it will either load the cached
 * version, or if there is not one, load the real thing and create a cache
 * object which can then be easily stored.
 */
function layout_get_layout_cache($layout_name) {
  $caches = &drupal_static(__FUNCTION__, array());
  if (!isset($caches[$layout_name])) {
    $cache = tempstore_get('layout', $layout_name);
    if (!$cache) {
      $cache = new stdClass();
      $cache->name = $layout_name;
      $cache->task = page_manager_get_task($cache->task_id);
      if (empty($cache->task)) {
        return FALSE;
      }

      $cache->handlers = page_manager_load_sorted_handlers($cache->task, $cache->subtask_id);
      $cache->handler_info = array();
      foreach ($cache->handlers as $id => $handler) {
        $cache->handler_info[$id] = array(
          'weight' => $handler->weight,
          'changed' => FALSE,
          'name' => $id,
        );
      }
    }
    else {
      // ensure the task is loaded.
      $cache = layout_get_layout($layout_name);
    }

    $caches[$layout_name] = $cache;
  }

  return $caches[$layout_name];
}

/**
 * Store changes to a task handler in the object cache.
 */
function layout_set_layout_cache($layout) {
  if (!empty($layout->locked)) {
    return;
  }

  if (empty($layout->name)) {
    return;
  }

  $layout->changed = TRUE;
  tempstore('layout.layout', $layout->name, $page);
}

/**
 * Remove an item from the object cache.
 */
function layout_clear_layout_cache($name) {
  ctools_object_cache_clear('page_manager_page', $name);
}

/**
 * Write all changes from the page cache and clear it out.
 */
function layout_save_layout_cache($cache) {
  // Save the subtask:
  if ($function = ctools_plugin_get_function($cache->task, 'save subtask callback')) {
    $function($cache->subtask, $cache);
  }

  // Iterate through handlers and save/delete/update as necessary.
  // Go through each of the task handlers, check to see if it needs updating,
  // and update it if so.
  foreach ($cache->handler_info as $id => $info) {
    $handler = &$cache->handlers[$id];
    // If it has been marked for deletion, delete it.

    if ($info['changed'] & PAGE_MANAGER_CHANGED_DELETED) {
      page_manager_delete_task_handler($handler);
    }
    // If it has been somehow edited (or added), write the cached version
    elseif ($info['changed'] & PAGE_MANAGER_CHANGED_CACHED) {
      // Make sure we get updated weight from the form for this.
      $handler->weight = $info['weight'];
      page_manager_save_task_handler($handler);
    }
    // Otherwise, check to see if it has moved and, if so, update the weight.
    elseif ($info['weight'] != $handler->weight) {
      // Theoretically we could only do this for in code objects, but since our
      // load mechanism checks for all, this is less database work.
      page_manager_update_task_handler_weight($handler, $info['weight']);
    }

    // Set enable/disabled status.
    if ($info['changed'] & PAGE_MANAGER_CHANGED_STATUS) {
      ctools_include('export');
      ctools_export_set_object_status($cache->handlers[$id], $info['disabled']);
    }
  }

  page_manager_clear_page_cache($cache->task_name);

  if (!empty($cache->path_changed) || !empty($cache->new)) {
    // Force a menu rebuild to make sure the menu entries are set.
    menu_rebuild();
  }
  cache_clear_all();
}

/**
 * Menu callback to load a page manager cache object for menu callbacks.
 */
function layout_cache_load($layout_name) {
  return layout_get_layout_cache($layout_name);
}

/**
 * Generate a unique name for a task handler.
 *
 * Task handlers need to be named but they aren't allowed to set their own
 * names. Instead, they are named based upon their parent task and type.
 */
function page_manager_handler_get_name($task_name, $handlers, $handler) {
  $base = str_replace('-', '_', $task_name);
  // Generate a unique name. Unlike most named objects, we don't let people choose
  // names for task handlers because they mostly don't make sense.
  $base .= '_' . $handler->handler;

  // Once we have a base, check to see if it is used. If it is, start counting up.
  $name = $base;
  $count = 1;
  // If taken
  while (isset($handlers[$name])) {
    $name = $base . '_' . ++$count;
  }

  return $name;
}

/**
 * Import a handler into a page.
 *
 * This is used by both import and clone, since clone just exports the
 * handler and immediately imports it.
 */
function page_manager_handler_add_to_page(&$page, &$handler, $title = NULL) {
  $last = end($page->handler_info);
  $handler->weight = $last ? $last['weight'] + 1 : 0;
  $handler->task = $page->task_id;
  $handler->subtask = $page->subtask_id;
  $handler->export_type = EXPORT_IN_DATABASE;
  $handler->type = t('Normal');

  if ($title) {
    $handler->conf['title'] = $title;
  }

  $name = page_manager_handler_get_name($page->task_name, $page->handlers, $handler);

  $handler->name = $name;

  $page->handlers[$name] = $handler;
  $page->handler_info[$name] = array(
    'weight' => $handler->weight,
    'name' => $handler->name,
    'changed' => PAGE_MANAGER_CHANGED_CACHED,
  );
}

/**
 * Create a new task handler object.
 *
 * @param $plugin
 *   The plugin this task handler is created from.
 */
function page_manager_new_task_handler($plugin) {
  // Generate a unique name. Unlike most named objects, we don't let people choose
  // names for task handlers because they mostly don't make sense.

  // Create a new, empty handler object.
  $handler          = new stdClass;
  $handler->title   = $plugin['title'];
  $handler->task    = NULL;
  $handler->subtask = NULL;
  $handler->name    = NULL;
  $handler->handler = $plugin['name'];
  $handler->weight  = 0;
  $handler->conf    = array();

  // These are provided by the core export API provided by ctools and we
  // set defaults here so that we don't cause notices. Perhaps ctools should
  // provide a way to do this for us so we don't have to muck with it.
  $handler->export_type = EXPORT_IN_DATABASE;
  $handler->type = t('Local');

  if (isset($plugin['default conf'])) {
    if (is_array($plugin['default conf'])) {
      $handler->conf = $plugin['default conf'];
    }
    else if (function_exists($plugin['default conf'])) {
      $handler->conf = $plugin['default conf']($handler);
    }
  }

  return $handler;
}

