<?php

/**
 * @file
 * The page manager module provides a UI and API to manage pages.
 *
 * It defines pages, both for system pages, overrides of system pages, and
 * custom pages using Drupal's normal menu system. It allows complex
 * manipulations of these pages, their content, and their hierarchy within
 * the site. These pages can be exported to code for superior revision
 * control.
 */

/**
 * Layouts constant for user-defined layouts.
 */
const LAYOUT_STORAGE_NORMAL = 1;

/**
 * Layout constant for layouts that override module-defined presets.
 */
const LAYOUT_STORAGE_OVERRIDE = 2;

/**
 * Layout constant for module-defined layouts.
 */
const LAYOUT_STORAGE_DEFAULT = 4;

/**
 * Layout constant indicating the title of the layout is manually specified.
 */
const LAYOUT_TITLE_FIXED = 0;

/**
 * Layout constant indicating the title of the layout is not shown.
 */
const LAYOUT_TITLE_NONE = 1;

/**
 * Layout constant indicating the title of the layout comes from a block.
 */
const LAYOUT_TITLE_BLOCK = 2;

/**
 * Implements hook_permission().
 */
function page_manager_permission() {
  return array(
    'administer layouts' => array(
      'title' => t('Administer Layouts'),
      'description' => t('Add and modify layouts on pages.'),
      'restrict access' => TRUE,
    ),
  );
}

/**
 * Implements hook_menu().
 */
function layout_menu() {
  $items = array();
  $base = array(
    'access arguments' => array('administer layouts'),
    'file' => 'includes/layout.admin.inc',
    'theme callback' => 'ajax_base_page_theme',
  );

  $items['admin/structure/layouts'] = array(
    'title' => 'Layouts',
    'description' => 'Create new landing pages or modify the layout of existing pages on your site.',
    'page callback' => 'layout_list_page',
    'type' => MENU_NORMAL_ITEM,
  ) + $base;

  $items['admin/structure/layouts/reorder'] = array(
    'title' => 'List',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('layout_reorder_form'),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_cache'] = array(
    'title' => 'Edit layout settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('layout_settings_form', 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_cache/edit'] = array(
    'title' => 'Layout',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_cache/settings'] = array(
    'title' => 'Settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('layout_settings_form', 4),
    'type' => MENU_LOCAL_TASK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_cache/operation'] = array(
    'page callback' => 'layout_edit_layout_operation',
    'page arguments' => array(4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_cache/clone'] = array(
    'title' => 'Clone layout',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('layout_clone_form', 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_cache/enable'] = array(
    'page callback' => 'layout_enable_layout',
    'page arguments' => array(FALSE, 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_cache/disable'] = array(
    'page callback' => 'layout_enable_layout',
    'page arguments' => array(TRUE, 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/manage/%layout_cache/delete'] = array(
    'page callback' => 'drupal_get_form',
    'page arguments' => array('layout_delete_form', 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/add'] = array(
    'title' => 'Add new layout',
    'page callback' => 'layout_add_page',
    'page arguments' => array(),
    'type' => MENU_LOCAL_ACTION,
  ) + $base;

  $items['admin/structure/layouts/menu/%layout_cache'] = array(
    'title' => 'Menu settings',
    'load arguments' => array('menu_item'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('layout_menu_item_settings_form', 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/menu/%layout_cache/arguments'] = array(
    'title' => 'Arguments',
    'load arguments' => array('menu_item'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('layout_menu_item_arguments_form', 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  $items['admin/structure/layouts/menu/%layout_cache/access'] = array(
    'title' => 'Access control',
    'load arguments' => array('menu_item'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('layout_menu_item_access_form', 4),
    'type' => MENU_CALLBACK,
  ) + $base;

  // AJAX callbacks for argument modal.
  $items['admin/structure/pages/argument'] = array(
      'page callback' => 'page_manager_page_subtask_argument_ajax',
      'type' => MENU_CALLBACK,
    ) + $base;

  // Add menu entries for each custom layout path.
  foreach (layout_get_all_layout_menu_items() as $menu_item) {
    if (!empty($menu_item->disabled)) {
      continue;
    }

    if (!isset($menu_item->access['type'])) {
      $menu_item->access['type'] = 'none';
    }
    if (!isset($menu_item->access['settings'])) {
      $menu_item->access['settings'] = NULL;
    }

    $path             = array();
    $page_arguments   = array($menu_item->name);
    $access_arguments = array($menu_item->access);
    $load_arguments   = array($menu_item->name, '%index', '%map');

    // Replace named placeholders with our own placeholder to load contexts.
    $position = 0;

    foreach (explode('/', $menu_item->path) as $bit) {
      // Remove things like double slashes completely.
      if (!isset($bit) || $bit === '') {
        continue;
      }

      if ($bit[0] == '%' && $bit != '%') {
        $placeholder = '%layout_arg';

        // Chop off that %.
        $name = substr($bit, 1);

        // Check to see if the argument plugin wants to use a different
        // placeholder. This will allow to_args.
        if (!empty($menu_item->arguments[$name])) {
          if (!empty($menu_item->arguments[$name]['name'])) {
            // @port: previously ctools_get_argument.
            $plugin = layout_get_argument($menu_item->arguments[$name]['name']);
            if (isset($plugin['path placeholder'])) {
              if (function_exists($plugin['path placeholder'])) {
                $placeholder = $plugin['path placeholder']($menu_item->arguments[$name]);
              }
              else {
                $placeholder = $plugin['path placeholder'];
              }
            }
          }
        }
        // If an argument, swap it out with our argument loader and make sure
        // the argument gets passed through to the page callback.
        $path[]             = $placeholder;
        $page_arguments[]   = $position;
        $access_arguments[] = $position;
      }
      else if ($bit[0] != '!') {
        $path[] = $bit;
      }

      // Increment position. We do it like this to skip empty items that
      // could happen from erroneous paths like: this///that
      $position++;
    }

    $menu_path = implode('/', $path);

    $items[$menu_path] = layout_page_menu_item($menu_item->menu, $access_arguments, $page_arguments, $load_arguments);

    // Add a parent menu item if one is configured.
    if (isset($menu_item->menu['type']) && $menu_item->menu['type'] == 'default tab') {
      array_pop($path);
      $parent_path = implode('/', $path);
      $items[$parent_path] = layout_page_menu_item($menu_item->menu['parent'], $access_arguments, $page_arguments, $load_arguments);
    }
  }

  return $items;
}

/**
 * Create a menu item for page manager pages.
 *
 * @param $menu
 *   The configuration to use. It will contain a type, and depending on the
 *   type may also contain weight, title and name. These are presumed to have
 *   been configured from the UI.
 * @param $access_arguments
 *   Arguments that go with ctools_access_menu; it should be loaded with
 *   the access plugin type, settings, and positions of any arguments that
 *   may produce contexts.
 * @param $page_arguments
 *   This should be seeded with the subtask name for easy loading and like
 *   the access arguments above should contain positions of arguments so
 *   that the menu system passes contexts through.
 * @param $load_arguments
 *   Arguments to send to the arg loader; should be the subtask id and '%index'.
 */
function layout_page_menu_item($menu, $access_arguments, $page_arguments, $load_arguments) {
  $item = array(
    'access callback' => 'layout_page_access',
    'access arguments' => $access_arguments,
    'page callback' => 'layout_page_callback',
    'page arguments' => $page_arguments,
    'load arguments' => $load_arguments,
    'file' => 'includes/layout.pages.inc',
  );

  if (isset($menu['title'])) {
    $item['title'] = $menu['title'];
  }
  if (isset($menu['weight'])) {
    $item['weight'] = $menu['weight'];
  }

  if (empty($menu['type'])) {
    $menu['type'] = 'none';
  }

  switch ($menu['type']) {
    case 'normal':
      $item['type'] = MENU_NORMAL_ITEM;
      // Insert item into the proper menu
      $item['menu_name'] = $menu['name'];
      break;

    case 'tab':
      $item['type'] = MENU_LOCAL_TASK;
      break;

    case 'action':
      $item['type'] = MENU_LOCAL_ACTION;
      break;

    case 'default tab':
      $item['type'] = MENU_DEFAULT_LOCAL_TASK;
      break;
    case 'none':
    default:
      $item['type'] = MENU_CALLBACK;
      break;
  }

  return $item;
}

/**
 * Menu access callback; Check access for any Layout-provided page.
 */
function layout_page_access() {
  module_load_include('inc', 'layout', 'includes/layout.pages');
  $args = func_get_args();
  return call_user_func_array('_layout_page_access', $args);
}

/**
 * Check to see if the incoming menu item is js capable or not.
 *
 * This can be used as %layout_js as part of a path in hook menu. CTools
 * ajax functions will automatically change the phrase 'nojs' to 'ajax'
 * when it attaches ajax to a link. This can be used to autodetect if
 * that happened.
 */
function layout_js_load($js) {
  if ($js == 'ajax') {
    return TRUE;
  }
  return 0;
}

/*
 * Implements hook_theme()
 */
function layout_theme() {
  $base = array(
    'file' => 'includes/layout.theme.inc',
  );

  $items = array(
    'layout_reorder_layouts' => array(
      'render element' => 'element',
    ) + $base,
    'layout_edit_form' => array(
      'template' => 'templates/layout-edit-page',
      'render element' => 'form',
    ) + $base,
    'layout_info' => array(
      'variables' => array('layout' => NULL),
    ) + $base,
    'layout_option' => array(
      'variables' => array('layout_info' => NULL),
    ) + $base,
    'layout_menu_item_arguments_table' => array(
      'render element' => 'element',
    ) + $base,
  );

  return $items;
}

/**
 * Implements hook_layout_api().
 */
function layout_layout_api() {
  return array(
    'file' => 'includes/layout.layout.inc',
  );
}

/**
 * Return an array of all layouts as fully loaded Layout objects.
 */
function layout_get_all_layouts() {
  $layouts = &drupal_static(__FUNCTION__);
  if (!isset($layouts)) {
    $layouts = array();
    $menu_items = layout_get_all_layout_menu_items();

    // Cache the raw config files once read.
    if ($cache = cache()->get('layout:layouts:config')) {
      $configs = $cache->data;
    }
    else {
      $configs = array();
      $config_names = config_get_names_with_prefix('layout.layout.');
      foreach ($config_names as $config_file) {
        $config = config($config_file);
        $data = $config->get();
        $data += array(
          'weight' => 0,
        );
        $configs[$data['name']] = $data;
      }
      // Sort the configs by name and weight.
      uasort($configs, function($a, $b) {
        if ($a['path'] == $b['path']) {
          if ($a['weight'] == $b['weight']) {
            return 0;
          }
          return ($a['weight'] < $b['weight']) ? -1 : 1;
        }
        else {
          return strcmp($a['path'], $b['path']);
        }
      });
      cache()->set('layout:layouts:config', $configs);
    }

    foreach ($configs as $layout_name => $layout_data) {
      // Create the layout from the configuration.
      $layouts[$layout_name] = new Layout($layout_data);

      // Associate the applicable menu item.
      if (isset($menu_items[$layout_data['path']])) {
        $layouts[$layout_name]->menu_item = $menu_items[$layout_data['path']];
      }
      else {
        $layouts[$layout_name]->menu_item = NULL;
      }
    }
  }

  return $layouts;
}

/**
 * Return an array of all menu items as fully loaded LayoutMenuItem objects.
 */
function layout_get_all_layout_menu_items() {
  $menu_items = &drupal_static(__FUNCTION__);
  if (!isset($menu_items)) {

    // Cache the raw config files once read.
    if ($cache = cache()->get('layout:menu_items:config')) {
      $configs = $cache->data;
    }
    else {
      $configs = array();
      $config_names = config_get_names_with_prefix('layout.menu_item.');
      foreach ($config_names as $config_file) {
        $config = config($config_file);
        $data = $config->get();
        $configs[$data['name']] = $data;
      }
      cache()->set('layout:menu_items:config', $configs);
    }

    $menu_items = array();
    foreach ($configs as $data) {
      $menu_items[$data['path']] = new LayoutMenuItem($data);
    }
  }
  return $menu_items;
}

/**
 * Get a list of layouts that share a particular path.
 */
function layout_get_path_layout_names($path) {
  $path_map = array();
  $layouts = layout_get_all_layouts();
  foreach ($layouts as $name => $layout) {
    $path_map[$layout->path][] = $name;
  }

  return isset($path_map[$path]) ? $path_map[$path] : array();
}
/**
 * Load an individual layout.
 */
function layout_load($layout_name) {
  $layouts = layout_get_all_layouts();
  return isset($layouts[$layout_name]) ? $layouts[$layout_name] : FALSE;
}

/**
 * Load an individual Layout menu item.
 */
function layout_menu_item_load($menu_item_name) {
  $menu_items = layout_get_all_layout_menu_items();
  $path = config_get('layout.menu_item.' . $menu_item_name, 'path');
  return $path && isset($menu_items[$path]) ? $menu_items[$path] : FALSE;
}

/**
 * Check if a path is provided by Layout module, as in a custom layout path.
 */
function layout_provides_path($path) {
  $result = db_query('SELECT * FROM {menu_router} WHERE path = :path', array(':path' => $path));
  $return = FALSE;

  // If any page callback exists at this path, allow it to trump custom layouts.
  foreach ($result as $router) {
    if ($router->page_callback == 'layout_page_callback') {
      $return = TRUE;
    }
    else {
      $return = FALSE;
      break;
    }
  }
  return $return;
}

/**
 * Reset all caches provided by Layout module.
 */
function layout_reset_caches() {
  cache()->delete('layout:layouts:config');
  cache()->delete('layout:menu_items:config');

  drupal_static_reset('layout_get_all_layouts');
  drupal_static_reset('layout_get_all_layout_menu_items');
}

/**
 * Load all include files for modules that implement hook_layout_api().
 */
function _layout_include_files() {
  $included = &drupal_static(__FUNCTION__, FALSE);
  if (!$included) {
    foreach (module_implements('layout_api') as $module) {
      $function = $module . '_layout_api';
      $api_info = $function();
      if (isset($api_info['file'])) {
        include_once(DRUPAL_ROOT . '/' . drupal_get_path('module', $module) . '/' . $api_info['file']);
      }
    }
    $included = TRUE;
  }
}

/**
 * Load a layout-related information from modules.
 */
function _layout_get_all_info($data_type) {
  $all_info = &drupal_static(__FUNCTION__);
  if (!isset($all_info[$data_type])) {
    _layout_include_files();
    if ($cached_info = cache()->get($data_type . '_info')) {
      $all_info[$data_type] = $cached_info->data;
    }
    else {
      $all_info[$data_type] = array();
      foreach (module_implements($data_type . '_info') as $module) {
        $function = $module . '_' . $data_type . '_info';
        $data = $function();
        foreach ($data as $key => $info) {
          $info['module'] = $module;
          $info['name'] = $key;
          $all_info[$data_type][$key] = $info;
        }
      }
      cache()->set($data_type . '_info', $all_info[$data_type]);
    }
  }
  return $all_info[$data_type];
}

/**
 * Load all layout information from modules.
 */
function layout_get_layout_info() {
  return _layout_get_all_info('layout');
}

/**
 * Load all layout information from modules.
 */
function layout_get_context_info() {
  return _layout_get_all_info('layout_context');
}

/**
 * Helper function to instantiate handlers when loading from config.
 *
 * @param string $handler
 *   The class name of the handler to instantiate.
 * @param array $config
 *   The configuration options for the handler being created.
 */
function layout_create_handler($handler, array $config = array()) {
  if (!class_exists($handler)) {
    if (class_exists($handler . 'Broken')) {
      $handler = $handler . 'Broken';
    }
    else {
      $handler = 'LayoutHandlerBroken';
    }
  }
  return new $handler($config);
}

/**
 * Helper function to create a Layout Context.
 */
function layout_create_context($context_name, $config = array()) {
  $context_info = layout_get_context_info();
  if (isset($context_info[$context_name])) {
    $handler = $context_info[$context_name]['context class'];
  }
  else {
    $handler = 'LayoutContextBroken';
  }
  return layout_create_handler($handler, $config);
}

/**
 * Get the cached changes to a given task handler.
 *
 * The page cache is used to store a page temporarily, using the ctools object
 * cache. When loading from the page cache, it will either load the cached
 * version, or if there is not one, load the real thing and create a cache
 * object which can then be easily stored.
 *
 * @param string $name
 *   The machine name of the Layout item to load.
 * @param string $type
 *   The type of item to load. Must be either "layout" or "menu_item".
 */
function layout_get_layout_cache($name, $type = 'layout') {
  $caches = &drupal_static(__FUNCTION__, array());
  if (!isset($caches[$type][$name])) {
    // Try loading from tempstore first to get in-progress changes.
    $item = tempstore_get('layout.' . $type, $name);
    if (!$item) {
      if ($type == 'layout') {
        $item = layout_load($name);
      }
      elseif ($type == 'menu_item') {
        $item = layout_menu_item_load($name);
      }
    }
    $caches[$type][$name] = $item;
  }

  return $caches[$type][$name];
}

/**
 * Store changes to a task handler in the object cache.
 */
function layout_set_layout_cache($item, $type = 'layout') {
  if (!empty($item->locked)) {
    return;
  }
  if (empty($item->name)) {
    return;
  }
  $item->changed = TRUE;
  tempstore_set('layout.' . $type, $item->name, $item, 604800);
}

/**
 * Remove an item from the object cache.
 */
function layout_clear_layout_cache($name, $type = 'layout') {
  tempstore_clear('layout.' . $type, $name);
}

/**
 * Menu callback to load a page manager cache object for menu callbacks.
 */
function layout_cache_load($layout_name, $type = 'layout') {
  return layout_get_layout_cache($layout_name, $type);
}

/**
 * Generate a unique name for a task handler.
 *
 * Task handlers need to be named but they aren't allowed to set their own
 * names. Instead, they are named based upon their parent task and type.
 */
function page_manager_handler_get_name($task_name, $handlers, $handler) {
  $base = str_replace('-', '_', $task_name);
  // Generate a unique name. Unlike most named objects, we don't let people choose
  // names for task handlers because they mostly don't make sense.
  $base .= '_' . $handler->handler;

  // Once we have a base, check to see if it is used. If it is, start counting up.
  $name = $base;
  $count = 1;
  // If taken
  while (isset($handlers[$name])) {
    $name = $base . '_' . ++$count;
  }

  return $name;
}

/**
 * Import a handler into a page.
 *
 * This is used by both import and clone, since clone just exports the
 * handler and immediately imports it.
 */
function page_manager_handler_add_to_page(&$page, &$handler, $title = NULL) {
  $last = end($page->handler_info);
  $handler->weight = $last ? $last['weight'] + 1 : 0;
  $handler->task = $page->task_id;
  $handler->subtask = $page->subtask_id;
  $handler->export_type = EXPORT_IN_DATABASE;
  $handler->type = t('Normal');

  if ($title) {
    $handler->conf['title'] = $title;
  }

  $name = page_manager_handler_get_name($page->task_name, $page->handlers, $handler);

  $handler->name = $name;

  $page->handlers[$name] = $handler;
  $page->handler_info[$name] = array(
    'weight' => $handler->weight,
    'name' => $handler->name,
    'changed' => PAGE_MANAGER_CHANGED_CACHED,
  );
}

/**
 * Create a new task handler object.
 *
 * @param $plugin
 *   The plugin this task handler is created from.
 */
function page_manager_new_task_handler($plugin) {
  // Generate a unique name. Unlike most named objects, we don't let people choose
  // names for task handlers because they mostly don't make sense.

  // Create a new, empty handler object.
  $handler          = new stdClass;
  $handler->title   = $plugin['title'];
  $handler->task    = NULL;
  $handler->subtask = NULL;
  $handler->name    = NULL;
  $handler->handler = $plugin['name'];
  $handler->weight  = 0;
  $handler->conf    = array();

  // These are provided by the core export API provided by ctools and we
  // set defaults here so that we don't cause notices. Perhaps ctools should
  // provide a way to do this for us so we don't have to muck with it.
  $handler->export_type = EXPORT_IN_DATABASE;
  $handler->type = t('Local');

  if (isset($plugin['default conf'])) {
    if (is_array($plugin['default conf'])) {
      $handler->conf = $plugin['default conf'];
    }
    else if (function_exists($plugin['default conf'])) {
      $handler->conf = $plugin['default conf']($handler);
    }
  }

  return $handler;
}

